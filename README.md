"# Data-Structures-and-Alogorithms-Practise" 

**step-by-step beginner roadmap** for learning **Data Structures and Algorithms (DSA)**

**four progressive stages**: Foundations → Core DSA → Problem Solving → Advanced Concepts.

---

## **Stage 1: Foundations (1–2 weeks)**

Before touching algorithms, get the basics rock-solid.

### 1. **Understand Programming Fundamentals**

* Variables, data types, and operators
* Loops (`for`, `while`)
* Conditionals (`if-else`)
* Functions (parameters, return values)
* Input/Output
* **Language choice:** Python, Java, C++, or JavaScript — choose one and stick with it.

**Resources:**

* *freeCodeCamp’s Basic Programming Tutorials* (YouTube)
* *CS50’s Introduction to Computer Science* (for a deeper foundation)

---

### 2. **Big-O Notation Basics**

* What is time complexity & space complexity?
* Common complexities: O(1), O(log n), O(n), O(n²)
* How to roughly estimate runtime.

**Practice:** Explain why a simple loop is O(n) and nested loops are O(n²).

---

## **Stage 2: Core Data Structures (3–5 weeks)**

This is where you learn the "tools in your toolbox."

### **A. Linear Data Structures**

1. **Arrays / Lists**

   * Indexing, insertion, deletion, iteration
   * Common problems: reversing, finding min/max, rotations.

2. **Strings**

   * Immutability, concatenation, substring search
   * Problems: palindrome check, anagram check.

3. **Stacks**

   * LIFO principle
   * Implementation with arrays/lists
   * Problems: valid parentheses, undo feature.

4. **Queues & Deques**

   * FIFO principle
   * Circular queue, priority queue basics.

5. **Linked Lists**

   * Singly vs doubly linked
   * Traversal, insertion, deletion.

---

### **B. Non-linear Data Structures**

6. **Hash Tables / Dictionaries / Maps**

   * Key-value pairs, hashing basics
   * Problems: frequency count, two-sum.

7. **Trees**

   * Binary trees, binary search trees (BST)
   * Traversals: inorder, preorder, postorder
   * Problems: find height, search in BST.

8. **Graphs (Basics)**

   * Adjacency list vs matrix
   * BFS & DFS traversal.

---

## **Stage 3: Core Algorithms (4–6 weeks)**

Now you combine data structures with logic.

1. **Searching**

   * Linear search (O(n))
   * Binary search (O(log n))

2. **Sorting**

   * Bubble sort, selection sort, insertion sort (for understanding)
   * Merge sort, quick sort (for efficiency)

3. **Recursion**

   * Base case, recursive case
   * Factorials, Fibonacci, tree traversal.

4. **Greedy Algorithms (Intro)**

   * Activity selection, coin change (greedy version).

5. **Dynamic Programming (Intro)**

   * Memoization, tabulation basics
   * Problems: climbing stairs, Fibonacci.

---

## **Stage 4: Problem-Solving & Practice (Ongoing)**

This is where most people actually *become good* at DSA.

### **Daily Practice Plan:**

* Pick **1–2 easy problems** per day, then move to medium level.
* Use platforms like:

  * **LeetCode** (Beginner-friendly: Easy problems list)
  * **HackerRank** (Structured topic-wise problems)
  * **Codeforces** (For timed contests later)

### **How to Solve Efficiently:**

1. Read the problem slowly, identify inputs/outputs.
2. Think of a **brute force** solution first.
3. Optimize step-by-step using better data structures.
4. Write pseudocode before actual code.

---

## **Stage 5: Advanced Concepts (Optional for beginners, 3–4 weeks)**

Once you’re comfortable:

* Heaps / Priority Queues
* Advanced Graph Algorithms (Dijkstra, Floyd-Warshall)
* Tries (for string search)
* Segment Trees / Fenwick Trees (for range queries)

---

### **Tips for Success**

* **Focus on concepts, not memorization.**
* **Visualize**: Use sites like [visualgo.net](https://visualgo.net/) to see how structures work.
* **Consistency beats intensity** — 1 hour a day is better than 6 hours once a week.
* **Track progress**: Keep a Google Sheet of problems solved.



**100-problem DSA practice list** 

## **📜 100 Problems DSA Practice List**

*(All problems are available on LeetCode unless noted otherwise.)*

---

### **Level 1: Arrays (10 problems)**

1. Two Sum — LC 1
2. Best Time to Buy and Sell Stock — LC 121
3. Contains Duplicate — LC 217
4. Move Zeroes — LC 283
5. Maximum Subarray (Kadane’s) — LC 53
6. Intersection of Two Arrays II — LC 350
7. Rotate Array — LC 189
8. Plus One — LC 66
9. Merge Sorted Array — LC 88
10. Remove Duplicates from Sorted Array — LC 26

---

### **Level 2: Strings (10 problems)**

11. Valid Palindrome — LC 125
12. Valid Anagram — LC 242
13. First Unique Character in a String — LC 387
14. Reverse String — LC 344
15. Implement strStr() — LC 28
16. Longest Common Prefix — LC 14
17. Ransom Note — LC 383
18. Is Subsequence — LC 392
19. Group Anagrams — LC 49
20. Longest Palindrome — LC 409

---

### **Level 3: Stack & Queue (10 problems)**

21. Valid Parentheses — LC 20
22. Min Stack — LC 155
23. Evaluate Reverse Polish Notation — LC 150
24. Implement Queue using Stacks — LC 232
25. Daily Temperatures — LC 739
26. Next Greater Element I — LC 496
27. Implement Stack using Queues — LC 225
28. Remove All Adjacent Duplicates in String — LC 1047
29. Crawler Log Folder — LC 1598
30. Baseball Game — LC 682

---

### **Level 4: Linked Lists (10 problems)**

31. Reverse Linked List — LC 206
32. Merge Two Sorted Lists — LC 21
33. Remove Linked List Elements — LC 203
34. Linked List Cycle — LC 141
35. Palindrome Linked List — LC 234
36. Remove Duplicates from Sorted List — LC 83
37. Intersection of Two Linked Lists — LC 160
38. Middle of the Linked List — LC 876
39. Delete Node in a Linked List — LC 237
40. Add Two Numbers — LC 2

---

### **Level 5: Hashing (10 problems)**

41. Two Sum — LC 1 (Review)
42. Happy Number — LC 202
43. Contains Duplicate II — LC 219
44. Intersection of Two Arrays — LC 349
45. Longest Substring Without Repeating Characters — LC 3
46. Subarray Sum Equals K — LC 560
47. Top K Frequent Elements — LC 347
48. Find the Difference — LC 389
49. Majority Element — LC 169
50. Word Pattern — LC 290

---

### **Level 6: Recursion (10 problems)**

51. Fibonacci Number — LC 509
52. Factorial (Custom problem)
53. Pow(x, n) — LC 50
54. Swap Nodes in Pairs — LC 24
55. Merge Two Sorted Lists (recursive) — LC 21
56. Climbing Stairs — LC 70
57. Generate Parentheses — LC 22
58. Letter Combinations of a Phone Number — LC 17
59. Combinations — LC 77
60. Permutations — LC 46

---

### **Level 7: Binary Search (10 problems)**

61. Binary Search — LC 704
62. Search Insert Position — LC 35
63. Guess Number Higher or Lower — LC 374
64. First Bad Version — LC 278
65. Find Smallest Letter Greater Than Target — LC 744
66. Peak Index in a Mountain Array — LC 852
67. Search in Rotated Sorted Array — LC 33
68. Find Minimum in Rotated Sorted Array — LC 153
69. Koko Eating Bananas — LC 875
70. Capacity to Ship Packages Within D Days — LC 1011

---

### **Level 8: Trees (10 problems)**

71. Maximum Depth of Binary Tree — LC 104
72. Symmetric Tree — LC 101
73. Same Tree — LC 100
74. Invert Binary Tree — LC 226
75. Diameter of Binary Tree — LC 543
76. Merge Two Binary Trees — LC 617
77. Path Sum — LC 112
78. Minimum Depth of Binary Tree — LC 111
79. Balanced Binary Tree — LC 110
80. Binary Tree Level Order Traversal — LC 102

---

### **Level 9: Graphs (10 problems)**

81. Number of Islands — LC 200
82. Flood Fill — LC 733
83. Max Area of Island — LC 695
84. Rotting Oranges — LC 994
85. Clone Graph — LC 133
86. Keys and Rooms — LC 841
87. Course Schedule — LC 207
88. Find if Path Exists in Graph — LC 1971
89. Word Ladder — LC 127
90. Pacific Atlantic Water Flow — LC 417

---

### **Level 10: Dynamic Programming (10 problems)**

91. Climbing Stairs — LC 70 (Review)
92. Min Cost Climbing Stairs — LC 746
93. House Robber — LC 198
94. House Robber II — LC 213
95. Unique Paths — LC 62
96. Unique Paths II — LC 63
97. Coin Change — LC 322
98. Longest Increasing Subsequence — LC 300
99. Maximum Product Subarray — LC 152
100. Edit Distance — LC 72

---

✅ **How to Use This List**

* Start from **Level 1** and complete in order.
* Do **2–3 problems a day** for steady progress.
* Revisit “Review” problems at least twice after a week.
* Keep notes on patterns you spot.