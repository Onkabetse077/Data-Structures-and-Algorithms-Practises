1. What is Big-O Notation?
 *Big O Notation is used to describe the performance of an algorithm.
 
 #O(1) – Constant Time

 *What it means: The algorithm takes the same amount of time no matter how big the input is.

 *Analogy: You have a stack of papers and you just grab the top one — whether there are 5 or 5,000 papers, it takes the same time.

 #O(n) – Linear Time

 *What it means: The algorithm takes time proportional to the size of the input. Double the input, double the time.

 *Analogy: You check each paper in a stack one by one. More papers = more time.


2.What O(n²) Means

 #O(n²) is called quadratic time.

 *It happens when the amount of work grows like the square of the input size.

 *In simpler terms: if you double the input, the work roughly quadruples.

 #Real-Life Example:

 *Imagine you’re in a classroom and you want every student to shake hands with every other student.

 *5 students → 5 × 5 = 25 handshakes (well, actually 10, but for growth we think of n²)

 *10 students → 10 × 10 = 100 handshakes

 *100 students → 100 × 100 = 10,000 handshakes

 *Notice how the work grows really fast as more people are added. That’s O(n²).


3.What O(n³) Means

*It’s called cubic time.

*The number of steps grows like n × n × n.

*If you double the input size, the time increases eight times (because 2³ = 8).

 #Real-Life Analogy

*Imagine you’re arranging students into all possible groups of 3 from a class of n students.

 *With 2 students → can’t really form a group of 3.

*With 10 students → lots of groups.

*With 100 students → the number of groups explodes.

*The work grows very fast because you’re considering 3 levels of choices.


4.What is O(log n)?

 *Called logarithmic time.

 *The work grows very slowly as n increases.

 #Example: Binary Search → cut the search space in half each step.

 *If you have n = 16 elements, it only takes at most log₂(16) = 4 steps to find something!
 
 #O(log n) binary search can be written in two styles:

 *Iterative (loop-based) → what I already showed you.

 *Recursive (function calls itself) → also O(log n).


6.What is O(n log n)?

 *Common in efficient sorting algorithms (Merge Sort, Quick Sort, Heap Sort).

 #Why?

 *The log n part comes from splitting the array into halves repeatedly.

 *The n part comes from processing all elements at each level of splitting.

 *Total work = n × log n.